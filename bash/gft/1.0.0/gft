#!/bin/bash

# gft - GitHub Fetch Tool
# Fetch release info, assets, and downloads from any GitHub project
# Usage: gft <user/repo> [tag] [options]

set -e

# Version
GFT_VERSION="1.0.0"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
BLUE='\033[1;94m'
YELLOW='\033[1;33m'
CYAN='\033[1;36m'
MAGENTA='\033[1;35m'
NC='\033[0m'

# Unicode symbols (no emojis)
SYM_OK="\xe2\x9c\x93"       # ✓
SYM_FAIL="\xe2\x9c\x97"     # ✗
SYM_ARROW="\xe2\x86\x92"    # →
SYM_BULLET=">"               # section header
SYM_DOT="-"                  # info line
SYM_DASH="\xe2\x94\x80"     # ─
SYM_TEE="\xe2\x94\x9c"      # ├
SYM_CORNER="\xe2\x94\x94"   # └
SYM_VLINE="\xe2\x94\x82"    # │

# ─── Color support ───────────────────────────────────────────────────

setup_colors() {
    if [[ -n "${NO_COLOR:-}" ]] || [[ ! -t 1 ]]; then
        RED='' GREEN='' BLUE='' YELLOW='' CYAN='' MAGENTA='' NC=''
    fi
}

# ─── Help ────────────────────────────────────────────────────────────

show_help() {
    echo -e "${BLUE}gft${NC} ${CYAN}${GFT_VERSION}${NC} - GitHub Fetch Tool"
    echo
    echo "Usage:"
    echo "  gft <user/repo> [tag]            Show release info (latest by default)"
    echo "  gft <user/repo> --assets         List release binary assets"
    echo "  gft <user/repo> --detect         Auto-detect best asset for your OS"
    echo "  gft <user/repo> --get <pattern>  Download asset matching pattern"
    echo "  gft <user/repo> --notes          Show release notes"
    echo "  gft <user/repo> --json           Output as JSON"
    echo "  gft <user/repo> -q               Output version number only"
    echo "  gft <user/repo> v1.0..v2.0       Compare two releases"
    echo
    echo "Options:"
    echo "  -h, --help         Show this help"
    echo "  -v, --version      Show version"
    echo "  --check-update     Check if a newer version is available"
    echo "  --no-color         Disable colors"
    echo
    echo "Environment:"
    echo "  NO_COLOR          Set to disable colors"
    echo "  GITHUB_TOKEN      Set for higher API rate limits"
    echo
    echo "Examples:"
    echo "  gft cli/cli                      Latest release of GitHub CLI"
    echo "  gft nodejs/node v22.0.0          Specific release"
    echo "  gft cli/cli --assets             List all binary downloads"
    echo "  gft cli/cli --detect             Find the right binary for you"
    echo "  gft cli/cli --get linux-amd64    Download matching binary"
    echo "  VERSION=\$(gft nodejs/node -q)    Script-friendly version"
}

# ─── Self-update check ───────────────────────────────────────────────

GFT_REPO="20syldev/gft"

check_update() {
    echo -e "${SYM_ARROW} Checking for updates..."

    local latest
    latest=$(curl -sL --max-time 5 "https://github.com/$GFT_REPO/releases" 2>/dev/null \
        | grep -o 'href="[^"]*/releases/tag/[^"]*"' | head -1 | sed 's/.*\/tag\///; s/".*//')

    if [[ -z "$latest" ]]; then
        echo -e "${YELLOW}${SYM_FAIL} Could not check for updates${NC}"
        return 1
    fi

    # Strip leading 'v' for comparison
    local current_clean="${GFT_VERSION#v}"
    local latest_clean="${latest#v}"

    if [[ "$current_clean" == "$latest_clean" ]]; then
        echo -e "${GREEN}${SYM_OK} gft ${GFT_VERSION} is up to date${NC}"
    else
        echo -e "${YELLOW}${SYM_BULLET} Update available: ${CYAN}${GFT_VERSION}${NC} ${SYM_ARROW} ${GREEN}${latest}${NC}"
        echo
        echo -e "  ${BLUE}Via apt:${NC}    sudo apt update && sudo apt upgrade"
        echo -e "  ${BLUE}Via .deb:${NC}   ${CYAN}gft $GFT_REPO --get deb${NC}"
        echo -e "  ${BLUE}Release:${NC}    https://github.com/$GFT_REPO/releases/tag/$latest"
    fi
}

# ─── Fetch utilities ─────────────────────────────────────────────────

fetch_page() {
    curl -sL --max-time 10 "$1" 2>/dev/null
}

fetch_api() {
    local endpoint="$1"
    # Try gh cli first if available and authenticated
    if command -v gh &>/dev/null && gh auth status &>/dev/null 2>&1; then
        gh api "$endpoint" 2>/dev/null && return 0
    fi
    # Fallback to curl with optional token
    local headers=()
    if [[ -n "${GITHUB_TOKEN:-}" ]]; then
        headers=(-H "Authorization: token $GITHUB_TOKEN")
    fi
    curl -sL --max-time 10 "${headers[@]}" "https://api.github.com/$endpoint" 2>/dev/null
}

# ─── Repository checks ──────────────────────────────────────────────

check_repository_exists() {
    local repo_url="https://github.com/$REPO"
    local response

    response=$(curl -s -o /dev/null -w "%{http_code}" "$repo_url" 2>/dev/null)

    if [ "$response" = "200" ]; then
        return 0
    elif [ "$response" = "404" ]; then
        echo -e "${RED}${SYM_FAIL} Repository not found:${NC} $REPO"
        echo -e "  Expected format: ${YELLOW}username/repository${NC}"
        echo -e "  Example: ${YELLOW}nodejs/node${NC}"
        exit 1
    else
        echo -e "${YELLOW}${SYM_FAIL} Unable to verify repository (HTTP $response)${NC}"
        return 1
    fi
}

# ─── Tag resolution ──────────────────────────────────────────────────

get_latest_tag() {
    local releases_url="https://github.com/$REPO/releases"
    local response

    response=$(fetch_page "$releases_url")

    if [ -n "$response" ]; then
        local found_tag
        found_tag=$(echo "$response" | grep -o 'href="[^"]*/releases/tag/[^"]*"' | head -1 | sed 's/.*\/tag\///; s/".*//')

        if [ -n "$found_tag" ]; then
            echo "$found_tag"
            return 0
        fi
    fi

    return 1
}

resolve_tag() {
    local silent=false
    if [[ "${MODE_QUIET:-false}" == true ]] || [[ "${MODE_JSON:-false}" == true ]]; then
        silent=true
    fi

    if [ "$TAG" = "latest" ]; then
        local latest_tag
        latest_tag=$(get_latest_tag) || true
        if [ -n "$latest_tag" ]; then
            TAG="$latest_tag"
            if [[ "$silent" != true ]]; then
                echo -e "${GREEN}${SYM_OK} Latest release: ${YELLOW}$TAG${NC}"
            fi
        else
            if [[ "$silent" != true ]]; then
                echo -e "${YELLOW}${SYM_FAIL} No release tag found${NC}"
                echo -e "  ${CYAN}${SYM_BULLET} Check: https://github.com/$REPO/releases${NC}"
            fi
            TAG="main"
        fi
    else
        if [[ "$silent" != true ]]; then
            echo -e "${GREEN}${SYM_OK} Tag: ${YELLOW}$TAG${NC}"
        fi
    fi
}

build_urls() {
    REPO_URL="https://github.com/$REPO"
    RELEASES_URL="$REPO_URL/releases"
    if [ "$TAG" != "main" ] && [ "$TAG" != "master" ]; then
        TAG_URL="$REPO_URL/releases/tag/$TAG"
        ZIP_URL="$REPO_URL/archive/refs/tags/${TAG}.zip"
        TARBALL_URL="$REPO_URL/archive/refs/tags/${TAG}.tar.gz"
    else
        TAG_URL="$REPO_URL/tree/$TAG"
        ZIP_URL="$REPO_URL/archive/refs/heads/${TAG}.zip"
        TARBALL_URL="$REPO_URL/archive/refs/heads/${TAG}.tar.gz"
    fi
}

# ─── Display functions ───────────────────────────────────────────────

display_info() {
    echo
    echo -e "${SYM_DOT} ${BLUE}Repository:${NC}  $REPO"
    echo -e "${SYM_DOT} ${BLUE}Tag:${NC}         $TAG"
    echo

    echo -e "${YELLOW}${SYM_BULLET} Links${NC}"
    echo -e "  ${SYM_TEE}${SYM_DASH} ${BLUE}Repository:${NC}   $REPO_URL"
    echo -e "  ${SYM_TEE}${SYM_DASH} ${BLUE}Releases:${NC}     $RELEASES_URL"
    if [ "$TAG" != "main" ] && [ "$TAG" != "master" ]; then
        echo -e "  ${SYM_CORNER}${SYM_DASH} ${BLUE}This release:${NC} $TAG_URL"
    else
        echo -e "  ${SYM_CORNER}${SYM_DASH} ${BLUE}Branch:${NC}       $TAG_URL"
    fi

    echo
    echo -e "${YELLOW}${SYM_BULLET} Source Archives${NC}"
    echo -e "  ${SYM_TEE}${SYM_DASH} ${BLUE}ZIP:${NC}    $ZIP_URL"
    echo -e "  ${SYM_CORNER}${SYM_DASH} ${BLUE}TAR.GZ:${NC} $TARBALL_URL"

    echo
    echo -e "${YELLOW}${SYM_BULLET} Quick Commands${NC}"
    echo -e "  ${SYM_TEE}${SYM_DASH} ${CYAN}curl -LO \"$ZIP_URL\"${NC}"
    echo -e "  ${SYM_TEE}${SYM_DASH} ${CYAN}curl -LO \"$TARBALL_URL\"${NC}"
    if [ "$TAG" != "main" ] && [ "$TAG" != "master" ]; then
        echo -e "  ${SYM_CORNER}${SYM_DASH} ${CYAN}git clone --depth 1 --branch $TAG $REPO_URL.git${NC}"
    else
        echo -e "  ${SYM_CORNER}${SYM_DASH} ${CYAN}git clone $REPO_URL.git${NC}"
    fi

    if [ "$TAG" != "main" ] && [ "$TAG" != "master" ]; then
        echo
        echo -e "${CYAN}${SYM_BULLET} API details:${NC} curl -s \"https://api.github.com/repos/$REPO/releases/tags/$TAG\""
    fi
}

# ─── Assets listing ──────────────────────────────────────────────────

get_assets() {
    local assets_url="https://github.com/$REPO/releases/expanded_assets/$TAG"
    local response
    response=$(fetch_page "$assets_url")

    if [[ -z "$response" ]]; then
        return 1
    fi

    echo "$response" | grep -oP 'href="\K/[^"]+/releases/download/[^"]+' | sort -u
}

list_assets() {
    local assets
    assets=$(get_assets) || true

    if [[ -z "$assets" ]]; then
        echo -e "${YELLOW}${SYM_FAIL} No binary assets found for this release${NC}"
        echo -e "  Source archives are available via the default view"
        return 0
    fi

    echo
    echo -e "${YELLOW}${SYM_BULLET} Release Assets ($TAG)${NC}"
    echo

    local count=0
    while IFS= read -r asset_path; do
        if [[ -z "$asset_path" ]]; then continue; fi
        local filename
        filename=$(basename "$asset_path")
        ((count++)) || true

        if [[ "${MODE_DETECT:-false}" == true ]]; then
            local match
            match=$(highlight_asset "$filename")
            if [[ "$match" == "match" ]]; then
                printf "  ${GREEN}${SYM_OK} %2d) %s  ${CYAN}<- recommended${NC}\n" "$count" "$filename"
            else
                printf "  %4d) %s\n" "$count" "$filename"
            fi
        else
            printf "  %4d) %s\n" "$count" "$filename"
        fi
    done <<< "$assets"

    echo
    echo -e "  ${GREEN}${count} asset(s) available${NC}"
}

# ─── Platform detection ──────────────────────────────────────────────

detect_platform() {
    local os arch
    os=$(uname -s | tr '[:upper:]' '[:lower:]')
    arch=$(uname -m)

    case "$os" in
        linux)           OS_PATTERNS=("linux") ;;
        darwin)          OS_PATTERNS=("darwin" "macos" "mac" "osx" "apple") ;;
        mingw*|msys*|cygwin*) OS_PATTERNS=("windows" "win" "win64" "win32") ;;
        freebsd)         OS_PATTERNS=("freebsd") ;;
        *)               OS_PATTERNS=("$os") ;;
    esac

    case "$arch" in
        x86_64|amd64)    ARCH_PATTERNS=("amd64" "x86_64" "x64" "64bit") ;;
        aarch64|arm64)   ARCH_PATTERNS=("arm64" "aarch64") ;;
        armv7l|armhf)    ARCH_PATTERNS=("armv7" "armhf" "arm") ;;
        i686|i386)       ARCH_PATTERNS=("386" "i386" "i686" "x86" "32bit") ;;
        *)               ARCH_PATTERNS=("$arch") ;;
    esac
}

highlight_asset() {
    local filename="$1"
    local filename_lower
    filename_lower=$(echo "$filename" | tr '[:upper:]' '[:lower:]')
    local os_match=false arch_match=false

    for pattern in "${OS_PATTERNS[@]}"; do
        local p_lower
        p_lower=$(echo "$pattern" | tr '[:upper:]' '[:lower:]')
        [[ "$filename_lower" == *"$p_lower"* ]] && os_match=true && break
    done

    for pattern in "${ARCH_PATTERNS[@]}"; do
        local p_lower
        p_lower=$(echo "$pattern" | tr '[:upper:]' '[:lower:]')
        [[ "$filename_lower" == *"$p_lower"* ]] && arch_match=true && break
    done

    if $os_match && $arch_match; then
        echo "match"
    fi
}

# ─── Release notes ───────────────────────────────────────────────────

show_release_notes() {
    # Try gh cli first for cleaner output
    if command -v gh &>/dev/null && gh auth status &>/dev/null 2>&1; then
        local notes
        notes=$(gh api "repos/$REPO/releases/tags/$TAG" --jq '.body' 2>/dev/null) || true
        if [[ -n "$notes" ]]; then
            echo
            echo -e "${YELLOW}${SYM_BULLET} Release Notes ($TAG)${NC}"
            local separator
            separator=$(printf '%0.s─' {1..40})
            echo -e "${CYAN}${separator}${NC}"
            echo "$notes" | head -80
            echo -e "${CYAN}${separator}${NC}"
            return 0
        fi
    fi

    # Fallback: scrape the release page
    local url="https://github.com/$REPO/releases/tag/$TAG"
    local response
    response=$(fetch_page "$url")

    if [[ -z "$response" ]]; then
        echo -e "${RED}${SYM_FAIL} Could not fetch release page${NC}"
        return 1
    fi

    local notes
    notes=$(echo "$response" | \
        sed -n '/data-test-selector="body-content"/,/<\/div>/p' | \
        sed 's/<[^>]*>//g' | \
        sed 's/&amp;/\&/g; s/&lt;/</g; s/&gt;/>/g; s/&quot;/"/g' | \
        sed "s/&#39;/'/g" | \
        sed '/^[[:space:]]*$/d' | \
        head -80)

    if [[ -z "$notes" ]]; then
        echo -e "${YELLOW}${SYM_FAIL} No release notes available for $TAG${NC}"
        return 0
    fi

    echo
    echo -e "${YELLOW}${SYM_BULLET} Release Notes ($TAG)${NC}"
    local separator
    separator=$(printf '%0.s─' {1..40})
    echo -e "${CYAN}${separator}${NC}"
    echo "$notes"
    echo -e "${CYAN}${separator}${NC}"
}

# ─── JSON output ─────────────────────────────────────────────────────

output_json() {
    # Try gh cli first for rich structured data
    if command -v gh &>/dev/null && gh auth status &>/dev/null 2>&1; then
        local api_data
        api_data=$(gh api "repos/$REPO/releases/tags/$TAG" 2>/dev/null) || true
        if [[ -n "$api_data" ]]; then
            echo "$api_data"
            return 0
        fi
    fi

    # Fallback: build JSON from scraped data
    local assets
    assets=$(get_assets) || true

    printf '{\n'
    printf '  "repository": "%s",\n' "$REPO"
    printf '  "tag": "%s",\n' "$TAG"
    printf '  "repo_url": "%s",\n' "$REPO_URL"
    printf '  "release_url": "%s",\n' "$TAG_URL"
    printf '  "zip_url": "%s",\n' "$ZIP_URL"
    printf '  "tarball_url": "%s",\n' "$TARBALL_URL"

    if [[ -n "$assets" ]]; then
        printf '  "assets": [\n'
        local first=true
        while IFS= read -r asset; do
            [[ -z "$asset" ]] && continue
            $first || printf ',\n'
            printf '    "https://github.com%s"' "$asset"
            first=false
        done <<< "$assets"
        printf '\n  ]\n'
    else
        printf '  "assets": []\n'
    fi

    printf '}\n'
}

# ─── Direct asset download ───────────────────────────────────────────

download_asset() {
    local pattern="$1"
    local assets
    assets=$(get_assets) || true

    if [[ -z "$assets" ]]; then
        echo -e "${RED}${SYM_FAIL} No release assets found${NC}"
        return 1
    fi

    local matches
    matches=$(echo "$assets" | grep -i "$pattern") || true

    local match_count=0
    if [[ -n "$matches" ]]; then
        match_count=$(echo "$matches" | wc -l)
    fi

    if [[ $match_count -eq 0 ]]; then
        echo -e "${RED}${SYM_FAIL} No assets matching '${pattern}'${NC}"
        echo -e "  Use ${YELLOW}--assets${NC} to list available assets"
        return 1
    elif [[ $match_count -gt 1 ]]; then
        echo -e "${YELLOW}${SYM_BULLET} Multiple assets match '${pattern}':${NC}"
        local i=0
        while IFS= read -r match; do
            ((i++)) || true
            echo -e "  ${BLUE}${i}${NC}) $(basename "$match")"
        done <<< "$matches"
        echo
        read -p "Select (1-${i}): " -r selection
        matches=$(echo "$matches" | sed -n "${selection}p")
    fi

    local url="https://github.com${matches}"
    local filename
    filename=$(basename "$matches")

    echo -e "${SYM_ARROW} Downloading ${CYAN}${filename}${NC}..."
    if curl -LO --progress-bar "$url"; then
        echo -e "${GREEN}${SYM_OK} Downloaded: ${filename}${NC}"
    else
        echo -e "${RED}${SYM_FAIL} Download failed${NC}"
        return 1
    fi
}

# ─── Version comparison ──────────────────────────────────────────────

compare_releases() {
    local from="$1" to="$2"

    echo -e "${YELLOW}${SYM_BULLET} Comparing: ${CYAN}${from}${NC} ${SYM_ARROW} ${CYAN}${to}${NC}"
    echo

    # Fetch releases page to find tags in range
    local releases_page
    releases_page=$(fetch_page "https://github.com/$REPO/releases")

    if [[ -n "$releases_page" ]]; then
        local all_tags
        all_tags=$(echo "$releases_page" | grep -oP '/releases/tag/\K[^"]+' | head -50)

        if [[ -n "$all_tags" ]]; then
            local in_range=false
            local count=0
            echo -e "${BLUE}Releases in range:${NC}"
            while IFS= read -r tag; do
                if [[ "$tag" == "$to" ]]; then in_range=true; fi
                if $in_range; then
                    ((count++)) || true
                    echo -e "  ${SYM_TEE}${SYM_DASH} ${CYAN}${tag}${NC}"
                    if [[ "$tag" == "$from" ]]; then break; fi
                fi
            done <<< "$all_tags"

            if [[ $count -eq 0 ]]; then
                echo -e "  ${YELLOW}Could not find both tags on the first releases page${NC}"
            fi
        fi
    fi

    echo
    echo -e "${YELLOW}${SYM_BULLET} Compare on GitHub:${NC}"
    echo -e "  ${CYAN}https://github.com/$REPO/compare/${from}...${to}${NC}"
}

# ─── Interactive download ────────────────────────────────────────────

prompt_download() {
    echo
    read -p "$(echo -e "${YELLOW}${SYM_ARROW} Download? ${NC}(z)ip, (t)ar.gz, (n)o [n]: ")" -n 1 -r
    echo

    if [[ $REPLY =~ ^[Zz]$ ]]; then
        echo -e "${SYM_ARROW} Downloading ZIP archive..."
        if curl -LO "$ZIP_URL" 2>/dev/null; then
            local filename
            filename=$(basename "$ZIP_URL")
            echo -e "${GREEN}${SYM_OK} Downloaded: ${filename}${NC}"
        else
            echo -e "${RED}${SYM_FAIL} Download error${NC}"
        fi
    elif [[ $REPLY =~ ^[Tt]$ ]]; then
        echo -e "${SYM_ARROW} Downloading TAR.GZ archive..."
        if curl -LO "$TARBALL_URL" 2>/dev/null; then
            local filename
            filename=$(basename "$TARBALL_URL")
            echo -e "${GREEN}${SYM_OK} Downloaded: ${filename}${NC}"
        else
            echo -e "${RED}${SYM_FAIL} Download error${NC}"
        fi
    fi
}

# ─── Argument parsing ────────────────────────────────────────────────

REPO=""
TAG="latest"
MODE_QUIET=false
MODE_ASSETS=false
MODE_DETECT=false
MODE_GET=false
MODE_NOTES=false
MODE_JSON=false
MODE_COMPARE=false
GET_PATTERN=""
TAG_FROM=""
TAG_TO=""

while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            show_help
            exit 0
            ;;
        -v|--version)
            echo "gft $GFT_VERSION"
            exit 0
            ;;
        --check-update)
            setup_colors
            check_update
            exit $?
            ;;
        --no-color)
            NO_COLOR=1
            shift
            ;;
        -q|--quiet)
            MODE_QUIET=true
            NO_COLOR=1
            shift
            ;;
        --assets)
            MODE_ASSETS=true
            shift
            ;;
        --detect)
            MODE_DETECT=true
            MODE_ASSETS=true
            shift
            ;;
        --get)
            MODE_GET=true
            GET_PATTERN="${2:-}"
            if [[ -z "$GET_PATTERN" ]]; then
                echo -e "${RED}${SYM_FAIL} --get requires a pattern argument${NC}"
                exit 1
            fi
            shift 2
            ;;
        --notes)
            MODE_NOTES=true
            shift
            ;;
        --json)
            MODE_JSON=true
            NO_COLOR=1
            shift
            ;;
        -*)
            echo -e "${RED}${SYM_FAIL} Unknown option: $1${NC}"
            show_help
            exit 1
            ;;
        *)
            if [ -z "$REPO" ]; then
                REPO="$1"
            elif [[ "$1" == *".."* ]]; then
                TAG_FROM="${1%%..*}"
                TAG_TO="${1##*..}"
                MODE_COMPARE=true
            else
                TAG="$1"
            fi
            shift
            ;;
    esac
done

# Apply color settings after parsing
setup_colors

# Validate repository argument
if [ -z "$REPO" ]; then
    show_help
    exit 0
fi

if [[ ! "$REPO" =~ ^[a-zA-Z0-9._-]+/[a-zA-Z0-9._-]+$ ]]; then
    echo -e "${RED}${SYM_FAIL} Invalid repository format: '$REPO'${NC}"
    echo -e "  Expected: ${YELLOW}username/repository${NC}"
    echo -e "  Example:  ${YELLOW}nodejs/node${NC}"
    exit 1
fi

# ─── Main flow ───────────────────────────────────────────────────────

# Init platform detection if needed
if [[ "$MODE_DETECT" == true ]]; then
    detect_platform
fi

if [[ "$MODE_QUIET" != true ]] && [[ "$MODE_JSON" != true ]]; then
    echo -e "${SYM_ARROW} Looking up ${YELLOW}$REPO${NC} (${CYAN}$TAG${NC})..."
fi

# Check repo exists
check_repository_exists

# Handle compare mode separately
if [[ "$MODE_COMPARE" == true ]]; then
    echo
    compare_releases "$TAG_FROM" "$TAG_TO"
    exit 0
fi

# Resolve tag
resolve_tag

# Build URLs
build_urls

# Dispatch by mode
if [[ "$MODE_QUIET" == true ]]; then
    echo "$TAG"
    exit 0
fi

if [[ "$MODE_JSON" == true ]]; then
    output_json
    exit 0
fi

if [[ "$MODE_GET" == true ]]; then
    download_asset "$GET_PATTERN"
    exit 0
fi

# Default display
display_info

# Append optional modes
if [[ "$MODE_ASSETS" == true ]]; then
    list_assets
fi

if [[ "$MODE_NOTES" == true ]]; then
    show_release_notes
fi

# Interactive download prompt (only in terminal, not piped)
if [[ -t 0 ]] && [[ "$MODE_ASSETS" != true ]] && [[ "$MODE_GET" != true ]]; then
    prompt_download
fi
